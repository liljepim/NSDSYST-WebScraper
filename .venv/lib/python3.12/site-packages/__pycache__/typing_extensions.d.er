##[pylyzer] failed /home/jepi/Documents/NSDSYST-MCO2/.venv/lib/python3.12/site-packages/typing_extensions.py 1752607605 157408
.abc: Never

.builtins: Never

.collections: Never

.collections: Never

.contextlib: Never

.enum: Never

.functools: Never

.inspect: Never

.io: Never

.keyword: Never

.operator: Never

.sys: Never

._types: Never

.typing: Never

.warnings: Never


.annotationlib: Never



.__all__: global::List!({"DefaultDict", "dataclass_transform", "Iterable", "NoDefault", "Pattern", "Any", "Set", "Type", "SupportsBytes", "clear_overloads", "SupportsFloat", "Iterator", "Self", "Sentinel", "MutableSequence", "OrderedDict", "Never", "get_origin", "SupportsRound", "TypeIs", "cast", "get_annotations", "AbstractSet", "AnyStr", "Literal", "Union", "Sized", "MutableSet", "Tuple", "List", "SupportsInt", "KeysView", "overload", "Sequence", "IntVar", "Hashable", "TypeAliasType", "TypeForm", "AsyncIterator", "SupportsIndex", "TypedDict", "SupportsAbs", "TextIO", "ParamSpecKwargs", "IO", "ForwardRef", "Dict", "MappingView", "Unpack", "Protocol", "runtime", "evaluate_forward_ref", "MutableMapping", "is_protocol", "AsyncIterable", "Writer", "NoExtraItems", "LiteralString", "get_overloads", "Counter", "AsyncGenerator", "Buffer", "get_original_bases", "Generator", "deprecated", "NoReturn", "Final", "ChainMap", "Reader", "get_protocol_members", "Text", "FrozenSet", "is_typeddict", "BinaryIO", "Match", "Optional", "AsyncContextManager", "TypeAlias", "Mapping", "Format", "assert_never", "override", "TYPE_CHECKING", "Doc", "Callable", "NewType", "no_type_check_decorator", "NotRequired", "Coroutine", "reveal_type", "ParamSpecArgs", "get_args", "Container", "ContextManager", "no_type_check", "runtime_checkable", "final", "Collection", "ItemsView", "ValuesView", "get_type_hints", "TypeVar", "Annotated", "assert_type", "TypeVarTuple", "Generic", "ClassVar", "SupportsComplex", "NamedTuple", "Reversible", "Required", "Awaitable", "ParamSpec", "Concatenate", "TypeGuard", "ReadOnly", "Deque"}, 117)
.PEP_560: {True}
.GenericMeta: {Type}
._PEP_696_IMPLEMENTED: Never
._FORWARD_REF_HAS_CLASS: Never
.Type__Sentinel: ClassType
.Type__Sentinel.__call__: () -> typing_extensions.Type__Sentinel
.Type__Sentinel.__repr__: (self: typing_extensions.Type__Sentinel) -> {"<sentinel>"}

typing_extensions = pyimport "typing_extensions"
._marker: .Type__Sentinel

._should_collect_from_parameters: (t: Obj) -> {t in Never}




.NoReturn: Never
.T: Never
.KT: Never
.VT: Never
.T_co: Never
.T_contra: Never

.___v_desugar_1: Never
.Any: Never

.Type__AnyMeta: ClassType
.Type__AnyMeta <: Never
.Type__AnyMeta.__instancecheck__: (self: typing_extensions.Type__AnyMeta, obj: Obj) -> Never
.Type__AnyMeta.__repr__: (self: typing_extensions.Type__AnyMeta) -> Never

.Any: ClassType



.ClassVar: Never
.Type__SpecialForm: ClassType
.Type__SpecialForm <: Never
.Type__SpecialForm.__doc__: Never
.Type__SpecialForm._getitem: Never
.Type__SpecialForm._name: Never
.Type__SpecialForm.__call__: (self: Obj, *args: Obj, **kwds := Obj) -> NoneType
.Type__SpecialForm.__slots__: global::Tuple([{"_name"}, {"__doc__"}, {"_getitem"}])
.Type__SpecialForm.__getattr__: (self: typing_extensions.Type__SpecialForm, item: Obj) -> Never
.Type__SpecialForm.__mro_entries__: (self: typing_extensions.Type__SpecialForm, bases: Obj) -> NoneType
.Type__SpecialForm.__repr__: (self: typing_extensions.Type__SpecialForm) -> Str
.Type__SpecialForm.__reduce__: (self: typing_extensions.Type__SpecialForm) -> Never
.Type__SpecialForm.__call__: (self: Obj, *args: Obj, **kwds := Obj) -> NoneType
.Type__SpecialForm.__or__: (self: typing_extensions.Type__SpecialForm, other: Obj) -> Never
.Type__SpecialForm.__ror__: (self: typing_extensions.Type__SpecialForm, other: Obj) -> Never
.Type__SpecialForm.__instancecheck__: (self: typing_extensions.Type__SpecialForm, obj: Obj) -> NoneType
.Type__SpecialForm.__subclasscheck__: (self: typing_extensions.Type__SpecialForm, cls: Obj) -> NoneType
.Type__SpecialForm.__getitem__: (self: typing_extensions.Type__SpecialForm, parameters: Obj) -> Never

.Type__ExtensionsSpecialForm: ClassType
.Type__ExtensionsSpecialForm <: Never
.Type__ExtensionsSpecialForm.__repr__: (self: typing_extensions.Type__ExtensionsSpecialForm) -> Str

.Final: Never

.final: Never




.IntVar: (name: Obj) -> Never

.Literal: Never

._flatten_literal_params: |T <: Structural({.__args__ = ?Type_80479}), Type_80479 <: global::Iterable(Obj), T <: Structural({.__args__ = ?Type_80479}), Type_80479 <: global::Iterable(Never)|(parameters: global::Iterable(T)) -> global::Tuple([T])
._value_and_type_iter: (params: global::Iterable(Never)) -> NoneType
._LiteralGenericAlias: ClassType

.Type__LiteralForm: ClassType
.Type__LiteralForm <: .Type__ExtensionsSpecialForm
.Type__LiteralForm._name: Never
.Type__LiteralForm.__call__: (doc: Str) -> typing_extensions.Type__LiteralForm
.Type__LiteralForm.__getitem__: (self: typing_extensions.Type__LiteralForm, parameters: global::Iterable(Structural({.__args__ = global::Iterable(Never)}))) -> Never

.Literal: .Type__LiteralForm


._overload_dummy: Never

.overload: Never
.get_overloads: Never
.clear_overloads: Never

._overload_registry: Never





.Type: Never
.Awaitable: Never
.Coroutine: Never
.AsyncIterable: Never
.AsyncIterator: Never
.Deque: Never
.DefaultDict: Never
.OrderedDict: Never
.Counter: Never
.ChainMap: Never
.Text: Never
.TYPE_CHECKING: Never

.___v_desugar_2: Never
.AsyncContextManager: Never
.AsyncGenerator: Never
.ContextManager: Never
.Generator: Never

._is_dunder: |Type_81243: Type, Type_81249: Type, Type_81101 <: Structural({.startswith = (self: Obj, ?81242) -> ?81243; .endswith = (self: Obj, ?81249) -> ?R}), Type_81242: Type, R: Type, O: Type|(attr: Type_81101) -> O
.Type__SpecialGenericAlias: ClassType
.Type__SpecialGenericAlias <: Never
.Type__SpecialGenericAlias._defaults: Never
.Type__SpecialGenericAlias.__call__: (origin: Obj, nparams: Obj, inst: Obj := Obj, name: Obj := Obj, defaults: Obj := Obj) -> typing_extensions.Type__SpecialGenericAlias
.Type__SpecialGenericAlias.__setattr__: |Type_81242 :> {"__"}, Type_81243 <: Structural({.__and__ = (self: Never, ?R) -> ?O}), Type_81249 :> {"__"}, R: Type, O: Type, T <: Structural({.startswith = (self: Obj, ?Type_81242) -> ?Type_81243; .endswith = (self: Obj, ?Type_81249) -> ?R})|(self: typing_extensions.Type__SpecialGenericAlias, attr: T, val: Obj) -> NoneType
.Type__SpecialGenericAlias.__getitem__: (self: typing_extensions.Type__SpecialGenericAlias, params: Obj) -> Never

._NoneType: Never
.Generator: Never
.AsyncGenerator: Never
.ContextManager: Never
.AsyncContextManager: Never


._PROTO_ALLOWLIST: global::Dict!({{"typing_extensions"}: global::List!({"Buffer"}, 1), {"collections.abc"}: global::List!({"Iterator", "Awaitable", "Hashable", "Reversible", "Sized", "Buffer", "Collection", "Container", "Callable", "AsyncIterable", "Iterable"}, 11), {"contextlib"}: global::List!({"AbstractContextManager", "AbstractAsyncContextManager"}, 2)})
._EXCLUDED_ATTRS: Never
._get_protocol_attrs: |Type_77315 <: Structural({.__mro__ = ?81864}), Type_81864: Type|(cls: Type_77315) -> Never
._caller: |R :> {1}, R: Type|(depth: Structural({.__add__ = (self: Never, R) -> Never and (self: Never, R) -> Never}) := {1} and Structural({.__add__ = (self: Never, R) -> Never and (self: Never, R) -> Never}), default: R := {"__main__"} and R) -> {None}

.Protocol: Never

._allow_reckless_class_checks: (depth: Structural({.__add__ = (self: Never, Obj) -> Never}) := {2} and Structural({.__add__ = (self: Never, Obj) -> Never})) -> Bool
._no_init: (self: Obj, *args: Obj, **kwargs := Obj) -> NoneType
._type_check_issubclass_arg_1: (arg: Obj) -> NoneType
.Type__ProtocolMeta: ClassType
.Type__ProtocolMeta <: Never
.Type__ProtocolMeta.__call__: (cls: Obj, *args: Obj, **kwargs := Obj) -> typing_extensions.Type__ProtocolMeta
.Type__ProtocolMeta.__new__: |Type_82154 <: Structural({.__len__ = (self: Never) -> Nat})|(mcls: Obj, name: Obj, bases: Type_82154, namespace: Obj, **kwargs := Obj) -> Never
.Type__ProtocolMeta.__subclasscheck__: |Type_82728: Type, Type_82727: Type, Type_82162 <: Structural({.__dict__ = ?82728; .__non_callable_proto_members__ = ?82727 and ?82790}), T: Type, Type_82790 <: global::Iterable(?T)|(cls: Type_82162, other: Obj) -> Never
.Type__ProtocolMeta.__instancecheck__: |Type_82888: Type, Type_82870 <: global::Iterable(?T), T: Type, Type_82167 <: Structural({.__protocol_attrs__ = ?82870; .__non_callable_proto_members__ = ?82888})|(cls: Type_82167, instance: Obj) -> {False}
.Type__ProtocolMeta.__eq__: (cls: Obj, other: Obj) -> Bool
.Type__ProtocolMeta.__hash__: (cls: Obj) -> Int

._proto_hook: |Type_82977 <: global::Iterable(?T), Type_77416 <: Structural({.__protocol_attrs__ = ?82977}), T: Type|(cls: Type_77416, other: Structural({.__mro__ = global::Iterable(Never)})) -> {True}
.Protocol: ClassType




.runtime_checkable: Never




.runtime: Never

.SupportsInt: Never
.SupportsFloat: Never
.SupportsComplex: Never
.SupportsBytes: Never
.SupportsIndex: Never
.SupportsAbs: Never
.SupportsRound: Never

.SupportsInt: ClassType

.SupportsFloat: ClassType

.SupportsComplex: ClassType

.SupportsBytes: ClassType

.SupportsIndex: ClassType

.SupportsAbs: ClassType

.SupportsRound: ClassType




.Reader: Never
.Writer: Never

.Reader: ClassType

.Writer: ClassType



._NEEDS_SINGLETONMETA: {typing in not Structural({.NoExtraItems = Obj}) or not Structural({.NoDefault = Obj})}

.SingletonMeta: ClassType
.SingletonMeta <: Never
.SingletonMeta.__setattr__: (cls: Obj, attr: Obj, value: Obj) -> NoneType




.NoDefault: Never

.NoDefaultType: ClassType
.NoDefaultType.__call__: () -> typing_extensions.NoDefaultType
.NoDefaultType.__slots__: global::Tuple([])
.NoDefaultType.__new__: (cls: Obj) -> Never
.NoDefaultType.__repr__: (self: typing_extensions.NoDefaultType) -> {"typing_extensions.NoDefault"}
.NoDefaultType.__reduce__: (self: typing_extensions.NoDefaultType) -> {"NoDefault"}

.NoDefault: .NoDefaultType




.NoExtraItems: Never

.NoExtraItemsType: ClassType
.NoExtraItemsType.__call__: () -> typing_extensions.NoExtraItemsType
.NoExtraItemsType.__slots__: global::Tuple([])
.NoExtraItemsType.__new__: (cls: Obj) -> Never
.NoExtraItemsType.__repr__: (self: typing_extensions.NoExtraItemsType) -> {"typing_extensions.NoExtraItems"}
.NoExtraItemsType.__reduce__: (self: typing_extensions.NoExtraItemsType) -> {"NoExtraItems"}

.NoExtraItems: .NoExtraItemsType







._PEP_728_IMPLEMENTED: {False}

.TypedDict: Never
._TypedDictMeta: Never
.is_typeddict: Never

._TAKES_MODULE: Never
._get_typeddict_qualifiers: (annotation_type: Obj) -> NoneType
._TypedDictMeta: ClassType

._TypedDict: Never
._create_typeddict: (typename: Obj, fields: Obj, typing_is_inline: Bool, total: Obj, closed: Obj, extra_items: Obj, **kwargs := Obj) -> Never
.Type__TypedDictSpecialForm: ClassType
.Type__TypedDictSpecialForm <: .Type__SpecialForm
.Type__TypedDictSpecialForm.__call__: (self: typing_extensions.Type__TypedDictSpecialForm, typename: Obj, fields: Obj := Obj, total: Obj := Obj, closed: Obj := Obj, extra_items: Obj := Obj, **kwargs := Obj) -> Never
.Type__TypedDictSpecialForm.__mro_entries__: (self: typing_extensions.Type__TypedDictSpecialForm, bases: Obj) -> global::Tuple([Never])


._TYPEDDICT_TYPES: Never




.assert_type: Never





.get_type_hints: Never

._strip_extras: |E: Type, T: Type, Type_83594: Type, Type_78217 <: Structural({.__origin__ = ?83540 and ?T; .copy_with = (self: Obj, ?83594) -> ?83595; .__args__ = ?83559 and ?E}), Type_83540 <: ?83525, Type_83525: Type, Type_83559: Type, Type_83595: Type, Type_78217 <: Structural({.__origin__ = ?83540 and ?T; .copy_with = (self: Never, ?83594) -> ?83595; .__args__ = ?83559 and ?E})|(t: Type_78217) -> Type_78217


._could_be_inserted_optional: |Type_78219 <: Structural({.__args__ = ?83651}), Type_83651: Type|(t: Type_78219) -> {True}
._clean_optional: |Type_78224: Type, Type_83793: Type, Type_83698: Type, Type_78224 <: {_: ?78224 and NoneType | _ == None}, Type_78221 <: Structural({.__dict__ = ?83793; .__annotations__ = ?83698})|(obj: Type_78221, hints: Obj, globalns: Type_78224 := Type_78224, localns: Type_78224 := Type_78224) -> NoneType



.get_origin: Never
.get_args: Never






.TypeAlias: Never




._set_default: |Type_83854: Type, Type_78249: Type, Type_78246 <: Structural({.__default__ = ?78249; .has_default = ?83854})|(type_param: Type_78246, default: Type_78249) -> NoneType
._set_module: (typevarlike: Obj) -> NoneType
.Type__DefaultMixin: ClassType
.Type__DefaultMixin.__call__: () -> typing_extensions.Type__DefaultMixin
.Type__DefaultMixin.__slots__: global::Tuple([])

.Type__TypeVarLikeMeta: ClassType
.Type__TypeVarLikeMeta <: Never
.Type__TypeVarLikeMeta.__instancecheck__: |Type_83875 <: global::HomogenousTuple(ClassType) or ClassType, Type_78278 <: Structural({._backported_typevarlike = ?83875})|(cls: Type_78278, __instance: Obj) -> Bool


.___v_desugar_3: Never
.TypeVar: Never

.TypeVar: ClassType




.ParamSpecArgs: Never
.ParamSpecKwargs: Never

.Type__Immutable: ClassType
.Type__Immutable.__call__: () -> typing_extensions.Type__Immutable
.Type__Immutable.__slots__: global::Tuple([])
.Type__Immutable.__copy__: |Type_83907 <: typing_extensions.Type__Immutable|(self: Type_83907) -> Type_83907
.Type__Immutable.__deepcopy__: |Type_83909 <: typing_extensions.Type__Immutable|(self: Type_83909, memo: Obj) -> Type_83909

.ParamSpecArgs: ClassType

.ParamSpecKwargs: ClassType




.___v_desugar_4: Never
.ParamSpec: Never


.ParamSpec: ClassType


.ParamSpec: ClassType







._type_convert: |Type_78381: Type|(arg: Type_78381, module: Obj := Obj, allow_special_forms: Obj := Obj) -> Type_78381

._type_convert: Never


.Type__ConcatenateGenericAlias: ClassType
.Type__ConcatenateGenericAlias <: global::GenericList
.Type__ConcatenateGenericAlias.__origin__: Never
.Type__ConcatenateGenericAlias.__args__: Never
.Type__ConcatenateGenericAlias.__call__: (self: Obj, *args: Obj, **kwargs := Obj) -> NoneType
.Type__ConcatenateGenericAlias.__class__: Never
.Type__ConcatenateGenericAlias.__repr__: (self: typing_extensions.Type__ConcatenateGenericAlias) -> Str
.Type__ConcatenateGenericAlias.__hash__: (self: typing_extensions.Type__ConcatenateGenericAlias) -> Int
.Type__ConcatenateGenericAlias.__call__: (self: Obj, *args: Obj, **kwargs := Obj) -> NoneType
.Type__ConcatenateGenericAlias.__parameters__ : (self: typing_extensions.Type__ConcatenateGenericAlias) -> global::Tuple([Never])
.Type__ConcatenateGenericAlias.__parameters__: Never
.Type__ConcatenateGenericAlias.copy_with: (self: typing_extensions.Type__ConcatenateGenericAlias, params: typing_extensions.Type__SpecialForm or typing_extensions.Type__LiteralForm or typing_extensions.Type__SpecialGenericAlias) -> Never
.Type__ConcatenateGenericAlias.__getitem__: (self: typing_extensions.Type__ConcatenateGenericAlias, args: global::List!(Obj, 2)) -> Never


.Type__ConcatenateGenericAlias: Never

.Type__ConcatenateGenericAlias: ClassType
.Type__ConcatenateGenericAlias <: global::GenericList
.Type__ConcatenateGenericAlias.__origin__: Never
.Type__ConcatenateGenericAlias.__args__: Never
.Type__ConcatenateGenericAlias.__module__: {"typing"}
.Type__ConcatenateGenericAlias.copy_with: (self: typing_extensions.Type__ConcatenateGenericAlias, params: typing_extensions.Type__SpecialForm or typing_extensions.Type__ConcatenateGenericAlias or typing_extensions.Type__SpecialGenericAlias or typing_extensions.Type__LiteralForm) -> Never
.Type__ConcatenateGenericAlias.__getitem__: (self: typing_extensions.Type__ConcatenateGenericAlias, args: Obj) -> Never





.Type__EllipsisDummy: ClassType
.Type__EllipsisDummy.__call__: () -> typing_extensions.Type__EllipsisDummy

._create_concatenate_alias: (origin: Obj, parameters: typing_extensions.Type__SpecialForm or typing_extensions.Type__ConcatenateGenericAlias or typing_extensions.Type__SpecialGenericAlias or typing_extensions.Type__LiteralForm) -> Never
._concatenate_getitem: |Type_84848: Type, R: Type, E <: Structural({.__getitem__ = (self: Obj, ?R) -> ?84854 and (self: Obj, ?R) -> ?84848}), Type_84854: Type|(self: Obj, parameters: E) -> Never

.Concatenate: Never





.TypeGuard: Never





.TypeIs: Never





.TypeForm: Never

.Type__TypeFormForm: ClassType
.Type__TypeFormForm <: .Type__ExtensionsSpecialForm
.Type__TypeFormForm.__call__: |Type_84944: Type|(self: typing_extensions.Type__TypeFormForm, obj: Type_84944) -> Type_84944





.LiteralString: Never





.Self: Never





.Never: Never





.Required: Never
.NotRequired: Never






.ReadOnly: Never




._UNPACK_DOC: {"Type unpack operator.\n\nThe type unpack operator takes the child types from some container type,\nsuch as `tuple[int, str]` or a `TypeVarTuple`, and \'pulls them out\'. For\nexample:\n\n  # For some generic class `Foo`:\n  Foo[Unpack[tuple[int, str]]]  # Equivalent to Foo[int, str]\n\n  Ts = TypeVarTuple(\'Ts\')\n  # Specifies that `Bar` is generic in an arbitrary number of types.\n  # (Think of `Ts` as a tuple of an arbitrary number of individual\n  #  `TypeVar`s, which the `Unpack` is \'pulling out\' directly into the\n  #  `Generic[]`.)\n  class Bar(Generic[Unpack[Ts]]): ...\n  Bar[int]  # Valid\n  Bar[int, str]  # Also valid\n\nFrom Python 3.11, this can also be done using the `*` operator:\n\n    Foo[*tuple[int, str]]\n    class Bar(Generic[*Ts]): ...\n\nThe operator can also be used along with a `TypedDict` to annotate\n`**kwargs` in a function signature. For instance:\n\n  class Movie(TypedDict):\n    name: str\n    year: int\n\n  # This function expects two keyword arguments - *name* of type `str` and\n  # *year* of type `int`.\n  def foo(**kwargs: Unpack[Movie]): ...\n\nNote that there is only some runtime checking of this operator. Not\neverything the runtime allows may be accepted by static type checkers.\n\nFor more information, see PEP 646 and PEP 692.\n"}

.Unpack: Never
._is_unpack: Never

.Type__UnpackSpecialForm: ClassType
.Type__UnpackSpecialForm <: .Type__ExtensionsSpecialForm
.Type__UnpackSpecialForm.__doc__: Never
.Type__UnpackSpecialForm.__call__: (getitem: Obj) -> typing_extensions.Type__UnpackSpecialForm

.Type__UnpackAlias: ClassType
.Type__UnpackAlias <: Never
.Type__UnpackAlias.__typing_unpacked_tuple_args__ : (self: typing_extensions.Type__UnpackAlias) -> {None}
.Type__UnpackAlias.__typing_unpacked_tuple_args__: {None}
.Type__UnpackAlias.__typing_is_unpacked_typevartuple__ : (self: typing_extensions.Type__UnpackAlias) -> {.self.__args__.__getitem__(0) in Never}
.Type__UnpackAlias.__typing_is_unpacked_typevartuple__: {.self.__args__.__getitem__(0) in Never}
.Type__UnpackAlias.__getitem__: (self: typing_extensions.Type__UnpackAlias, args: Obj) -> Never





._unpack_args: (*args: Obj) -> global::List!(Never, 2)

.___v_desugar_5: Never
.TypeVarTuple: Never


.TypeVarTuple: ClassType


.TypeVarTuple: ClassType






.reveal_type: Never





._ASSERT_NEVER_REPR_MAX_LENGTH: Never

._ASSERT_NEVER_REPR_MAX_LENGTH: Never



.assert_never: Never





.dataclass_transform: Never





.override: Never

._F: Never




.deprecated: Never

._T: Never
.deprecated: ClassType




._is_param_expr: (arg: Obj) -> {arg in {Ellipsis} or global::List(Obj, _: Nat) or global::HomogenousTuple(Obj)}





._check_generic: |Type_85315: Type, Type_78761 <: Structural({.__len__ = (self: Never) -> Nat; .__getitem__ = (self: Obj, ?85314) -> ?85315}), Type_85314: Type|(cls: Never, parameters: Type_78761, elen: Bool := typing_extensions.Type__Sentinel and Bool) -> NoneType








._has_generic_or_protocol_as_origin: () -> Bool
._TYPEVARTUPLE_TYPES: global::Set!({None} or ClassType, _: Nat)
._is_unpacked_typevartuple: (x: Obj) -> Bool

._collect_type_vars: |T: Type, T <: Structural({.__parameters__ = ?Type_85513}), Type_85513 <: global::Iterable(?T)|(types: global::Iterable(T), typevar_types: global::HomogenousTuple(ClassType) or ClassType := global::HomogenousTuple(ClassType) or ClassType) -> global::Tuple([T])


._collect_parameters: (args: global::Iterable(Obj)) -> global::Tuple([Obj])







.NamedTuple: Never

._make_nmtuple: (name: Obj, types: Obj, module: Obj, defaults: Obj := Obj) -> Never
._prohibited_namedtuple_fields: Never
._special_namedtuple_fields: global::FrozenSet({"__module__", "__name__", "__annotations__"})
.Type__NamedTupleMeta: ClassType
.Type__NamedTupleMeta <: Never
.Type__NamedTupleMeta.__new__: |T <: typing_extensions.Type__SpecialForm or typing_extensions.Type__ConcatenateGenericAlias or typing_extensions.Type__UnpackAlias or typing_extensions.Type__SpecialGenericAlias or typing_extensions.Type__LiteralForm, Type_85828 :> global::Tuple([?T]), Type_85828 <: Structural({.__contains__ = (self: Never, ?T) -> Bool}), T: Type|(cls: Obj, typename: Obj, bases: Type_85828, ns: Structural({.items = (self: Obj) -> global::Iterable(T); .__contains__ = (self: Never, Obj) -> Bool; .__getitem__ = (self: Obj, Obj) -> global::Dict!({Never: Never}) and (self: Obj, Obj) -> ({1}) -> global::Dict!({Never: Never})})) -> Never

._NamedTuple: Never
._namedtuple_mro_entries: |Type_78918 <: Structural({.__contains__ = (self: Never, ?R) -> Bool and (self: Never, ?R) -> Bool}), R: Type|(bases: Type_78918) -> global::Tuple([Never])





.Buffer: Never

.Buffer: ClassType







.get_original_bases: Never





.NewType: Never

.NewType: ClassType




.TypeAliasType: Never


._is_unionable: (obj: Obj) -> {obj in {None} or Type}





._ATTRIBUTE_DELEGATION_EXCLUSIONS: global::FrozenSet({"__reduce__", "__mro_entries__", "__parameters__", "__copy__", "__deepcopy__", "__bases__", "__reduce_ex__", "__args__", "__unpacked__", "__class__", "__typing_unpacked_tuple_args__", "__origin__"})
.Type__TypeAliasGenericAlias: ClassType
.Type__TypeAliasGenericAlias <: Never
.Type__TypeAliasGenericAlias.__getattr__: (self: typing_extensions.Type__TypeAliasGenericAlias, attr: Str) -> Obj



.TypeAliasType: ClassType




.is_protocol: Never
.get_protocol_members: Never






.Doc: Never

.Doc: ClassType



._CapsuleType: {None}

._socket: Never


._CAPI: {None}








.CapsuleType: Never




.___v_desugar_7: Never
.Format: Never
.get_annotations: Never

.Format: ClassType





.evaluate_forward_ref: Never

._eval_with_owner: |Type_79547 <: Structural({.__forward_value__ = ?86655 and ?86675; .__forward_module__ = ?86704; .__forward_evaluated__ = ?86652 and ?86671; .__forward_code__ = ?87470; .__forward_is_class__ = ?R; .__forward_arg__ = ?R; .__cell__ = ?86667}), Type_86667: Type, Type_86652 <: Bool, Type_87470: Type, Type_86675: Type, Type_86671: Type, Type_86655: Type, Type_86704 <: Ref(Obj), R: Type|(forward_ref: Type_79547, owner: Obj := Obj, globals: NoneType := NoneType, locals: global::Dict({global::Tuple([Obj, Never]): Never}) := global::Dict({global::Tuple([Obj, Never]): Never}), type_params: Obj := Obj) -> Never



.Sentinel: ClassType
.Sentinel._name: Never
.Sentinel._repr: Never
.Sentinel.__call__: (name: Str, repr: NoneType or Str := NoneType or Str) -> typing_extensions.Sentinel
.Sentinel.__repr__: (self: typing_extensions.Sentinel) -> Never
.Sentinel.__getstate__: (self: typing_extensions.Sentinel) -> NoneType

._typing_names: global::List!({"Hashable", "Mapping", "Set", "IO", "Collection", "KeysView", "ValuesView", "Sized", "MappingView", "FrozenSet", "Sequence", "MutableSequence", "Callable", "Iterator", "Container", "ItemsView", "MutableSet", "Union", "MutableMapping", "no_type_check", "Pattern", "Tuple", "_AnnotatedAlias", "cast", "Optional", "Iterable", "AbstractSet", "Match", "Reversible", "Dict", "TextIO", "no_type_check_decorator", "BinaryIO", "List", "AnyStr"}, 35)

.Generic: Never
.ForwardRef: Never
.Annotated: Never
