##[pylyzer] failed /home/jepi/Documents/NSDSYST-MCO2/.venv/lib/python3.12/site-packages/urllib3/response.py 1752607604 46480
.___v_desugar_1: Never
.annotations: Never
.collections: Never

.io: Never

._json: Never

.logging: Never

.re: Never

.socket: Never

.sys: Never

.typing: Never

.warnings: Never

.zlib: Never

.___v_desugar_2: Never
.contextmanager: Never
.___v_desugar_3: Never
._HttplibHTTPMessage: Never
.___v_desugar_4: Never
._HttplibHTTPResponse: Never
.___v_desugar_5: Never
.SocketTimeout: Never

.___v_desugar_6 = pyimport "_base_connection"
._base_connection = pyimport "_base_connection"
.BaseHTTPConnection: {_base_connection.BaseHTTPConnection}


.brotli: Never

.brotli: Never




.___v_desugar_7 = pyimport "__init__"
.__init__ = pyimport "__init__"
.util: Never
.___v_desugar_8 = pyimport "_base_connection"

._TYPE_BODY: Never
.___v_desugar_9 = pyimport "_collections"
._collections = pyimport "_collections"
.HTTPHeaderDict: {_collections.HTTPHeaderDict}
.___v_desugar_10 = pyimport "connection"
.connection = pyimport "connection"
.BaseSSLError: Never
.HTTPConnection: Never
.HTTPException: Never
.___v_desugar_11 = pyimport "exceptions"
.exceptions = pyimport "exceptions"
.BodyNotHttplibCompatible: Never
.DecodeError: Never
.HTTPError: Never
.IncompleteRead: Never
.InvalidChunkLength: Never
.InvalidHeader: Never
.ProtocolError: Never
.ReadTimeoutError: Never
.ResponseNotChunked: Never
.SSLError: Never
.___v_desugar_12 = pyimport "response"
.response = pyimport "response"
.is_fp_closed: (obj: Obj) -> Bool
.is_response_to_head: (response: Obj) -> Bool
.___v_desugar_13 = pyimport "retry"
.retry = pyimport "retry"
.Retry: {util.retry.Retry}

.___v_desugar_14 = pyimport "connectionpool"
.connectionpool = pyimport "connectionpool"
.HTTPConnectionPool: {connectionpool.HTTPConnectionPool}


.log: Never
.ContentDecoder: ClassType
.ContentDecoder.__call__: () -> response.ContentDecoder
.ContentDecoder.decompress: (self: response.ContentDecoder, data: global::Bytes) -> global::Bytes
.ContentDecoder.flush: (self: response.ContentDecoder) -> global::Bytes

.DeflateDecoder: ClassType
.DeflateDecoder <: .ContentDecoder
.DeflateDecoder._first_try: Never
.DeflateDecoder._obj: Never
.DeflateDecoder._data: Never
.DeflateDecoder.__call__: () -> response.DeflateDecoder
.DeflateDecoder.decompress: (self: response.DeflateDecoder, data: global::Bytes) -> global::Bytes
.DeflateDecoder.flush: (self: response.DeflateDecoder) -> global::Bytes

.GzipDecoderState: ClassType
.GzipDecoderState.__call__: () -> response.GzipDecoderState
.GzipDecoderState.FIRST_MEMBER: {0}
.GzipDecoderState.OTHER_MEMBERS: {1}
.GzipDecoderState.SWALLOW_DATA: {2}

.GzipDecoder: ClassType
.GzipDecoder <: .ContentDecoder
.GzipDecoder._obj: Never
.GzipDecoder._state: Never
.GzipDecoder.__call__: () -> response.GzipDecoder
.GzipDecoder.decompress: (self: response.GzipDecoder, data: global::Bytes) -> global::Bytes
.GzipDecoder.flush: (self: response.GzipDecoder) -> global::Bytes


.BrotliDecoder: ClassType
.BrotliDecoder <: .ContentDecoder
.BrotliDecoder._obj: Never
.BrotliDecoder.__call__: () -> response.BrotliDecoder
.BrotliDecoder.flush: (self: response.BrotliDecoder) -> global::Bytes



.___v_desugar_15: Never
.zstd: Never
.HAS_ZSTD: {True}
.ZstdDecoder: ClassType
.ZstdDecoder <: .ContentDecoder
.ZstdDecoder._obj: Never
.ZstdDecoder.__call__: () -> response.ZstdDecoder
.ZstdDecoder.decompress: (self: response.ZstdDecoder, data: global::Bytes) -> global::Bytes
.ZstdDecoder.flush: (self: response.ZstdDecoder) -> global::Bytes

.zstd: Never

._zstd_version: Never






.ZstdDecoder: ClassType
.ZstdDecoder <: .ContentDecoder
.ZstdDecoder._obj: Never
.ZstdDecoder.__call__: () -> response.ZstdDecoder
.ZstdDecoder.decompress: (self: response.ZstdDecoder, data: global::Bytes) -> global::Bytes
.ZstdDecoder.flush: (self: response.ZstdDecoder) -> global::Bytes



.MultiDecoder: ClassType
.MultiDecoder <: .ContentDecoder
.MultiDecoder._decoders: Never
.MultiDecoder.__call__: (modes: Str) -> response.MultiDecoder
.MultiDecoder.flush: (self: response.MultiDecoder) -> global::Bytes
.MultiDecoder.decompress: (self: response.MultiDecoder, data: global::Bytes) -> global::Bytes

._get_decoder: (mode: Str) -> response.ContentDecoder
.BytesQueueBuffer: ClassType
.BytesQueueBuffer.buffer: Never
.BytesQueueBuffer._size: Int
.BytesQueueBuffer.__call__: () -> response.BytesQueueBuffer
.BytesQueueBuffer.__len__: (self: response.BytesQueueBuffer) -> Int
.BytesQueueBuffer.put: (self: response.BytesQueueBuffer, data: global::Bytes) -> NoneType
.BytesQueueBuffer.get: (self: response.BytesQueueBuffer, n: Int) -> global::Bytes
.BytesQueueBuffer.get_all: (self: response.BytesQueueBuffer) -> global::Bytes

.BaseHTTPResponse: ClassType
.BaseHTTPResponse <: Never
.BaseHTTPResponse.decode_content: Bool
.BaseHTTPResponse._request_url: NoneType or Str
.BaseHTTPResponse.status: Int
.BaseHTTPResponse.chunked: Never
.BaseHTTPResponse.version_string: Str
.BaseHTTPResponse.version: Int
.BaseHTTPResponse.reason: NoneType or Str
.BaseHTTPResponse._decoder: NoneType or response.ContentDecoder
.BaseHTTPResponse._has_decoded_content: Never
.BaseHTTPResponse.retries: NoneType or util.retry.Retry
.BaseHTTPResponse.__call__: (status: Int, version: Int, version_string: Str, reason: NoneType or Str, decode_content: Bool, request_url: NoneType or Str, headers: NoneType or global::Mapping(global::Bytes or Str, global::Bytes or Str) := NoneType or global::Mapping(global::Bytes or Str, global::Bytes or Str), retries: NoneType or util.retry.Retry := NoneType or util.retry.Retry) -> response.BaseHTTPResponse
.BaseHTTPResponse.CONTENT_DECODERS: Never
.BaseHTTPResponse.REDIRECT_STATUSES: Never
.BaseHTTPResponse.DECODER_ERROR_CLASSES: Never
.BaseHTTPResponse.get_redirect_location: (self: response.BaseHTTPResponse) -> NoneType or Str
.BaseHTTPResponse.data : (self: response.BaseHTTPResponse) -> global::Bytes
.BaseHTTPResponse.data: global::Bytes
.BaseHTTPResponse.json: (self: response.BaseHTTPResponse) -> Never
.BaseHTTPResponse.url : (self: response.BaseHTTPResponse) -> NoneType or Str
.BaseHTTPResponse.url: NoneType or Str
.BaseHTTPResponse.url: (self: response.BaseHTTPResponse, url: NoneType or Str) -> NoneType
.BaseHTTPResponse.connection : (self: response.BaseHTTPResponse) -> NoneType or _base_connection.BaseHTTPConnection
.BaseHTTPResponse.connection: NoneType or _base_connection.BaseHTTPConnection
.BaseHTTPResponse.retries : (self: response.BaseHTTPResponse) -> NoneType or util.retry.Retry
.BaseHTTPResponse.retries: NoneType or util.retry.Retry
.BaseHTTPResponse.retries: (self: response.BaseHTTPResponse, retries: NoneType or util.retry.Retry) -> NoneType
.BaseHTTPResponse.stream: (self: response.BaseHTTPResponse, amt: NoneType or Int := NoneType or Int, decode_content: NoneType or Bool := NoneType or Bool) -> global::Iterator(global::Bytes)
.BaseHTTPResponse.read: (self: response.BaseHTTPResponse, amt: NoneType or Int := NoneType or Int, decode_content: NoneType or Bool := NoneType or Bool, cache_content: Bool := Bool) -> global::Bytes
.BaseHTTPResponse.read1: (self: response.BaseHTTPResponse, amt: NoneType or Int := NoneType or Int, decode_content: NoneType or Bool := NoneType or Bool) -> global::Bytes
.BaseHTTPResponse.read_chunked: (self: response.BaseHTTPResponse, amt: NoneType or Int := NoneType or Int, decode_content: NoneType or Bool := NoneType or Bool) -> global::Iterator(global::Bytes)
.BaseHTTPResponse.release_conn: (self: response.BaseHTTPResponse) -> NoneType
.BaseHTTPResponse.drain_conn: (self: response.BaseHTTPResponse) -> NoneType
.BaseHTTPResponse.shutdown: (self: response.BaseHTTPResponse) -> NoneType
.BaseHTTPResponse.close: (self: response.BaseHTTPResponse) -> NoneType
.BaseHTTPResponse._init_decoder: (self: response.BaseHTTPResponse) -> NoneType
.BaseHTTPResponse._decode: (self: response.BaseHTTPResponse, data: global::Bytes, decode_content: NoneType or Bool, flush_decoder: Bool) -> global::Bytes
.BaseHTTPResponse._flush_decoder: (self: response.BaseHTTPResponse) -> global::Bytes
.BaseHTTPResponse.readinto: (self: response.BaseHTTPResponse, b: global::ByteArray!) -> Int
.BaseHTTPResponse.getheaders: (self: response.BaseHTTPResponse) -> _collections.HTTPHeaderDict
.BaseHTTPResponse.getheader: (self: response.BaseHTTPResponse, name: Str, default: NoneType or Str := NoneType or Str) -> NoneType or Str
.BaseHTTPResponse.info: (self: response.BaseHTTPResponse) -> _collections.HTTPHeaderDict
.BaseHTTPResponse.geturl: (self: response.BaseHTTPResponse) -> NoneType or Str

.HTTPResponse: ClassType
.HTTPResponse <: .BaseHTTPResponse
.HTTPResponse._fp_bytes_read: Never
.HTTPResponse._connection: Never
.HTTPResponse._original_response: Never
.HTTPResponse.length_remaining: Never
.HTTPResponse._decoded_buffer: Never
.HTTPResponse._body: Never
.HTTPResponse.msg: Never
.HTTPResponse.auto_close: Bool
.HTTPResponse._sock_shutdown: Never
.HTTPResponse._fp: Never
.HTTPResponse.enforce_content_length: Bool
.HTTPResponse._pool: Never
.HTTPResponse.chunk_left: NoneType or Int
.HTTPResponse.__call__: (body: Obj := Obj, headers: NoneType or global::Mapping(global::Bytes or Str, global::Bytes or Str) := NoneType or global::Mapping(global::Bytes or Str, global::Bytes or Str), status: Int := Int, version: Int := Int, version_string: Str := Str, reason: NoneType or Str := NoneType or Str, preload_content: Bool := Bool, decode_content: Bool := Bool, original_response: Obj := Obj, pool: Obj := Obj, connection: Obj := Obj, msg: Obj := Obj, retries: NoneType or util.retry.Retry := {None} and NoneType or util.retry.Retry, enforce_content_length: Bool := Bool, request_method: NoneType or Str := NoneType or Str, request_url: NoneType or Str := NoneType or Str, auto_close: Bool := Bool and Bool, sock_shutdown: NoneType or (Int) -> NoneType := {None} and NoneType or (Int) -> NoneType) -> response.HTTPResponse
.HTTPResponse.release_conn: (self: response.HTTPResponse) -> NoneType
.HTTPResponse.drain_conn: (self: response.HTTPResponse) -> NoneType
.HTTPResponse.data : (self: response.HTTPResponse) -> global::Bytes
.HTTPResponse.data: global::Bytes
.HTTPResponse.connection : (self: response.HTTPResponse) -> Never
.HTTPResponse.connection: Never
.HTTPResponse.isclosed: (self: response.HTTPResponse) -> Bool
.HTTPResponse.tell: (self: response.HTTPResponse) -> Int
.HTTPResponse._init_length: (self: response.HTTPResponse, request_method: NoneType or Str) -> NoneType or Int
.HTTPResponse._error_catcher: (self: response.HTTPResponse) -> Never
.HTTPResponse._fp_read: (self: response.HTTPResponse, amt: NoneType or Int := NoneType or Int, read1: Bool := Bool) -> global::Bytes
.HTTPResponse._raw_read: (self: response.HTTPResponse, amt: NoneType or Int := NoneType or Int, read1: Bool := Bool) -> global::Bytes
.HTTPResponse.read: (self: response.HTTPResponse, amt: NoneType or Int := {None} and NoneType or Int, decode_content: NoneType or Bool := {None} and NoneType or Bool, cache_content: Bool := Bool and Bool) -> global::Bytes
.HTTPResponse.read1: (self: response.HTTPResponse, amt: NoneType or Int := NoneType or Int, decode_content: NoneType or Bool := NoneType or Bool) -> global::Bytes
.HTTPResponse.stream: (self: response.HTTPResponse, amt: NoneType or Int := NoneType or Int, decode_content: NoneType or Bool := NoneType or Bool) -> NoneType
.HTTPResponse.readable: (self: response.HTTPResponse) -> Bool
.HTTPResponse.shutdown: (self: response.HTTPResponse) -> NoneType
.HTTPResponse.close: (self: response.HTTPResponse) -> NoneType
.HTTPResponse.closed : (self: response.HTTPResponse) -> Bool
.HTTPResponse.closed: Bool
.HTTPResponse.fileno: (self: response.HTTPResponse) -> Int
.HTTPResponse.flush: (self: response.HTTPResponse) -> NoneType
.HTTPResponse.supports_chunked_reads: (self: response.HTTPResponse) -> Bool
.HTTPResponse._update_chunk_length: (self: response.HTTPResponse) -> NoneType
.HTTPResponse._handle_chunk: (self: response.HTTPResponse, amt: NoneType or Int) -> global::Bytes
.HTTPResponse.read_chunked: (self: response.HTTPResponse, amt: NoneType or Int := NoneType or Int, decode_content: NoneType or Bool := NoneType or Bool) -> NoneType
.HTTPResponse.url : (self: response.HTTPResponse) -> NoneType or Str
.HTTPResponse.url: NoneType or Str
.HTTPResponse.url: (self: response.HTTPResponse, url: Str) -> NoneType
.HTTPResponse.__iter__: (self: response.HTTPResponse) -> global::Iterator(global::Bytes)

